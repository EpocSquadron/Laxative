#!/bin/bash

##########################################################################
## License                                                              ##
##                                                                      ##
## This Source Code Form is subject to the terms of the Mozilla Public  ##
## License, v. 2.0. If a copy of the MPL was not distributed with this  ##
## file, You can obtain one at http://mozilla.org/MPL/2.0/.             ##
##########################################################################

##########################################################
## Master configuration                                 ##
##########################################################

BACKUP_FILE_EXTENSION="bak"

##########################################################
## Define commands                                      ##
##########################################################

# Function to display usage
usage() {
  	read -r -d '' USAGE_TEXT <<HEREDOC
\033[1mUsage:\033[0m
	`basename $0` <command> <from_environment_shortname> [<to_environment_shortname>]

\033[1mDescription:\033[0m
	More easily create and load database backup/dump files with an eye towards CMS-oriented web development. Environment shortnames should match the names of the configuration files and dump files (e.g. shortname 'stage' corresponds to config.stage.php and stage-schema.sql).

\033[1mOptions:\033[0m
	\033[1mdump\033[0m - Take a dump.
		With one argument, reads config data for that environment, writes dump to that environment's files.
		With two arguments, reads config data for the first environment, writes dump to second environment's files.

	\033[1mload\033[0m - Load a dump.
		With one argument, reads config data for that environment, loads from that environment's files.
		With two arguments, reads config data for the first environment, loads from the second environment's files.

	\033[1mwipe\033[0m - Copy one environment's db to another's.
		Third argument required. Copies first environment's dump onto the second's (overwriting).

	\033[1mdebug\033[0m - Print all of the variables to investigate for errors.
HEREDOC

	echo -e "$USAGE_TEXT"
	exit 1
}

# Function for creating dump files.
dump() {
	if [ "$ENV_TO" = "" ]; then
		local DUMP_SCHEMA_FILE="$FROM_SCHEMA_FILE"
		local DUMP_DATA_FILE="$FROM_DATA_FILE"
		local DUMP_ROUTINES_FILE="$FROM_ROUTINES_FILE"
		local DUMP_TO="$ENV"

		local DUMP_MONGO_TO="$FROM_MONGO_DIR"
	else
		local DUMP_SCHEMA_FILE="$TO_SCHEMA_FILE"
		local DUMP_DATA_FILE="$TO_DATA_FILE"
		local DUMP_ROUTINES_FILE="$TO_ROUTINES_FILE"
		local DUMP_TO="$ENV_TO"

		local DUMP_MONGO_TO="$TO_MONGO_DIR"
	fi

	# Create backup first.
	if [ -f "$DUMP_SCHEMA_FILE" ]; then
		mv "$DUMP_SCHEMA_FILE" "$DUMP_SCHEMA_FILE.$BACKUP_FILE_EXTENSION"
	fi
	if [ -f "$DUMP_ROUTINES_FILE" ]; then
		mv "$DUMP_ROUTINES_FILE" "$DUMP_ROUTINES_FILE.$BACKUP_FILE_EXTENSION"
	fi
	if [ -f "$DUMP_DATA_FILE" ]; then
		mv "$DUMP_DATA_FILE" "$DUMP_DATA_FILE.$BACKUP_FILE_EXTENSION"
	fi

	# Do it.
	do_mysql_dump "$DUMP_SCHEMA_FILE" "$DUMP_ROUTINES_FILE" "$DUMP_DATA_FILE"

	# Do Mongo if credentials have been found
	if [ "${MONGO}" ]; then
		do_mongo_dump "$DUMP_MONGO_TO"
	fi

	echo "Database from environment $ENV dumped to files for environment $DUMP_TO."
	exit 0
}

# Function for loading dump files.
load() {
	if [ "$ENV_TO" = "" ]; then
		local LOAD_SCHEMA_FILE="$FROM_SCHEMA_FILE"
		local LOAD_DATA_FILE="$FROM_DATA_FILE"
		local LOAD_ROUTINES_FILE="$FROM_ROUTINES_FILE"
		local LOAD_FROM="$ENV"

		local LOAD_MONGO_FROM="$FROM_MONGO_DIR"
	else
		local LOAD_SCHEMA_FILE="$TO_SCHEMA_FILE"
		local LOAD_DATA_FILE="$TO_DATA_FILE"
		local LOAD_ROUTINES_FILE="$TO_ROUTINES_FILE"
		local LOAD_FROM="$ENV_TO"

		local LOAD_MONGO_FROM="$TO_MONGO_DIR"
	fi

	# Backup the database about to be overwritten first.
	do_mysql_dump "$FROM_SCHEMA_FILE.$BACKUP_FILE_EXTENSION" "$FROM_ROUTINES_FILE.$BACKUP_FILE_EXTENSION" "$FROM_DATA_FILE.$BACKUP_FILE_EXTENSION"

	# Update the database
	if [ -e "$LOAD_SCHEMA_FILE" -a -e "$LOAD_DATA_FILE" -a -e "$LOAD_ROUTINES_FILE" ]; then
		mysql --user="$USER" --password="$PASS" --host="$HOST" --port="$PORT" "$DB" < "$LOAD_SCHEMA_FILE"
		mysql --user="$USER" --password="$PASS" --host="$HOST" --port="$PORT" "$DB" < "$LOAD_DATA_FILE"
		mysql --user="$USER" --password="$PASS" --host="$HOST" --port="$PORT" "$DB" < "$LOAD_ROUTINES_FILE"
		echo "Database loaded into environment $ENV from environment $LOAD_FROM's dump files."
		exit 0
	else
		echo >&2 "One or more of the schema, data, and routines files for environment $LOAD_FROM are missing."
		exit 1
	fi

	# restore mongo db
	if [ "${MONGO}" ]; then
		mongorestore --host="$MONGO_HOST" --username="$MONGO_USER" --password="$MONGO_PASS" $LOAD_MONGO_FROM
	fi
}

# Function for copying one env's dump on top of another's
wipe() {
	# Create backup first.
	if [ -f "$TO_SCHEMA_FILE" ]; then
		mv "$TO_SCHEMA_FILE" "$TO_SCHEMA_FILE.$BACKUP_FILE_EXTENSION"
	fi
	if [ -f "$TO_ROUTINES_FILE" ]; then
		mv "$TO_ROUTINES_FILE" "$TO_ROUTINES_FILE.$BACKUP_FILE_EXTENSION"
	fi
	if [ -f "$TO_DATA_FILE" ]; then
		mv "$TO_DATA_FILE" "$TO_DATA_FILE.$BACKUP_FILE_EXTENSION"
	fi

	# Overwrite.
	cp -f "$FROM_SCHEMA_FILE" "$TO_SCHEMA_FILE"
	cp -f "$FROM_DATA_FILE" "$TO_DATA_FILE"
	cp -f "$FROM_ROUTINES_FILE" "$TO_ROUTINES_FILE"

	# Overwrite Mongo
	if [ "${MONGO}" ]; then
		cp -f -r "$FROM_MONGO_DIR" "$TO_MONGO_DIR"
	fi

	echo "Environment $ENV's dumps copied to environment $ENV_TO's dumps."
	exit 0
}

##########################################################
## Define helper funcitons                              ##
##########################################################

# Function for grabbing a config value out of an ee-master-confi configuration file.
# Arg1 File to search.
# Arg2 Keyword of config value to search for.
grab_php_config_value() {
	## Filter comments with sed
	## Remove single-line comments (// or # comment)
	#	s/\/\/.*$//;
	#   s/#.*//
	## Insert newlines before /*
	#	s/\/\*/\
	#	&/;
	## Insert newlines after */
	#	s/\*\//&\
	#	/
	## Remove one-line block comments (/* something */)
	#	/\/\*.*\*\//d;
	## Remove multi-line block comments
	##	(/* line 1
	##	  * line 2 */)
	#	/\/\*/,/\*\//d
	## Strip empty lines
	#	/^\ *$/d
	## Extract variable with perl
	## Lookbehind, but dont match for $1'] = '
	#	(?<=$1\'\]\ \=\ \')
	## Match anything that isn't the closing single quote
	#	([^']+)
	## Lookahead for closing single quote
	#	(?=\')
	sed 's/\/\/.*$//;s/#.*//;s/\/\*/\
	&/;s/\*\//&\
	/' "$1" | sed '/\/\*.*\*\//d;/\/\*/,/\*\//d;/^\ *$/d' | perl -lne "print \$1 if /(?<=$2['\"]\]\ \=\ ['\"])([^'\"]+)(?=['\"])/i"
}

do_mysql_dump() {
	# # Create a dump of the database schema
	# mysqldump \
	## Connection to localhost
	# 	--host=$HOST \
	# 	--port=$PORT \
	# 	--user=$USER \
	# 	--password=$PASS \
	## Drop everything first - Not drop database
	##  for compatibility with cPanel
	# 	--add-drop-table \
	## Skip commenting, as timestamp changes diff
	#  --skip-comments
	## Make sure to recreate every detail
	# 	--create-options \
	## Use utf8
	# 	--default-character-set=utf8 \
	## Don't dump the data
	# 	--no-data \
	## Save db to schema.sql
	# 	$DB >schema.sql

	# create mysql dir if doesn't exist
	mkdir -p .sql

	mysqldump --host="$HOST" --port="$PORT" --user="$USER" --password="$PASS" --add-drop-table --skip-comments --create-options --default-character-set=utf8 --no-data "$DB" | sed '/^\/\*\!50013/d' >"$1"

	# # Create a dump of the routines (functions & procedures) only.
	#
	mysqldump --host="$HOST" --port="$PORT" --user="$USER" --password="$PASS" --routines --skip-triggers --no-create-info --no-data --no-create-db --skip-opt "$DB" >"$2"

	# # Create a dump of the actual data
	# mysqldump \
	## Connection to localhost
	# 	--host=$HOST \
	# 	--port=$PORT \
	# 	--user=$USER \
	# 	--password=$PASS \
	## Include column names in inserts
	# 	--complete-insert \
	## Skip commenting, as timestamp changes diff
	#  --skip-comments
	## Make loading faster by delaying index creation
	# 	--disable-keys \
	## Use VALUES (row1), (row2),.. for smaller file, faster insert
	# 	--extended-insert \
	## Don't replicate db and table data
	# 	--no-create-db \
	# 	--no-create-info \
	## Don't buffer rows in case db very large
	# 	--quick \
	##  Split VALUES (),(),...,(); into newline separated
	##  This makes diffs smaller for git.
	# 	$DB | sed 's/),(/),\
	#   (/g'
	## Save db to data.sql
	# >data.sql

	# Create a dump of the actual data
	mysqldump --host="$HOST" --port="$PORT" --user="$USER" --password="$PASS" --complete-insert --skip-comments --disable-keys --extended-insert --no-create-db --no-create-info --quick "$DB" | sed 's/),(/),\
	(/g' >"$3"
}

do_mongo_dump() {
	# create mongo directory if not exist
	mkdir -p .mongo

	# dump mongodb
	mongodump --host="$MONGO_HOST" --db="$MONGO_DB" --out="$1" --username="$MONGO_USER" --password="$MONGO_PASS"
}

check_mysql_db_connection() {
	local TEST=`mysql --host="$HOST" --port="$PORT" --user="$USER" --password="$PASS" -e "SHOW DATABASES;" | grep -iw "$DB"`
	if [ "$TEST" != "$DB" ]; then
		echo >&2 "Unable to connect to $ENV's database."
		exit 1
	fi
}

check_mongo_db_connection() {
	local TEST=`mongo "$MONGO_HOST"/"$MONGO_DB" --username "$MONGO_USER" --password "$MONGO_PASS" --quiet --eval "db"`
	if [ "$TEST" != "$MONGO_DB" ]; then
		echo >&2 "Unable to connect to $ENV's MongoDB."
		exit 1
	fi
}

##########################################################
## Checks before we do any more                         ##
##########################################################

# Check for existence/accessibility of mysql and sed
hash mysql 2>&- || { echo >&2 "Mysql is required but is either not installed or not in your PATH.  Aborting."; exit 1; }
hash mysqldump 2>&- || { echo >&2 "The mysqldump utility is required but is either not installed or not in your PATH.  Aborting."; exit 1; }
hash sed 2>&- || { echo >&2 "The sed utility is required but is either not installed or not in your PATH.  Aborting."; exit 1; }

# Check that user is asking for an action
if [ ! $1 ]; then
	usage
  	exit;
fi

###########################################################
## Set global variables and grab configuration           ##
###########################################################

# Find location of this script so we can save output to correct directory
DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Check that user supplied an env -- falback to local
if [ ! $2 ]; then
	usage
else
	ENV="$2"
fi

# Check for optional third argument
if [ ! $3 ]; then
	ENV_TO=""
else
	ENV_TO="$3"
fi

# Set defaults to prevent nonexistence errors.
DEFAULT_HOST="localhost"
DEFAULT_PORT="3306"
DEFAULT_USER="root"
DEFAULT_PASS="root"
DEFAULT_DB="test"

HOST="$DEFAULT_HOST"
PORT="$DEFAULT_PORT"
USER="$DEFAULT_USER"
PASS="$DEFAULT_PASS"
DB="$DEFAULT_DB"

# Path to possible configuration files
EEMASTERCONF_FILE="$DIR/../config/config.$ENV.php"
CI_ENV_CONF_FILE="$DIR/../application/config/$ENV/database.php"
CI_ENV_MONGO_CONF_FILE="$DIR/../application/config/$ENV/mongodb.php"
CONF_FILE="$DIR/$ENV.mysql.conf"
MONGO_CONF_FILE="$DIR/$ENV.mongo.conf"
WHICH_CONF=""

## Grab configuration
if [ -e "$EEMASTERCONF_FILE" ]; then
# Check if ee-master-config exists for this env, then pull form that
	HOST=`grab_php_config_value $EEMASTERCONF_FILE hostname`
	PORT=`grab_php_config_value $EEMASTERCONF_FILE port`
	USER=`grab_php_config_value $EEMASTERCONF_FILE username`
	PASS=`grab_php_config_value $EEMASTERCONF_FILE password`
	DB=`grab_php_config_value $EEMASTERCONF_FILE database`

	# If any of them are now empty, replace with default value
	for VAR in HOST PORT USER PASS DB; do
		if [ "${!VAR}" = "" ]; then
			TMP="DEFAULT_$VAR"
			eval $VAR="${!TMP}"
		fi
	done

	WHICH_CONF="ee-master-config"
elif [ -e "$CI_ENV_CONF_FILE" ]; then
# Check if ee-master-config exists for this env, then pull form that
	HOST=`grab_php_config_value $CI_ENV_CONF_FILE hostname`
	PORT=`grab_php_config_value $CI_ENV_CONF_FILE port`
	USER=`grab_php_config_value $CI_ENV_CONF_FILE username`
	PASS=`grab_php_config_value $CI_ENV_CONF_FILE password`
	DB=`grab_php_config_value $CI_ENV_CONF_FILE database`

	# If any of them are now empty, replace with default value
	for VAR in HOST PORT USER PASS DB; do
		if [ "${!VAR}" = "" ]; then
			TMP="DEFAULT_$VAR"
			eval $VAR="${!TMP}"
		fi
	done

	WHICH_CONF="codeigniter environment"
elif [ -e "$CONF_FILE" ]; then
# Check for configuration file as fallback.
	source "$CONF_FILE"
	WHICH_CONF="lax conf file ($CONF_FILE)"
else
# Error out.
	echo >&2 "Configuration file does not exist."; exit 1;
fi

# Now for Mongo
# See if mongodb configuration is in CI
if [ -e "$CI_ENV_MONGO_CONF_FILE" ]; then
# Check if CI env and then pull from that
	MONGO_HOST=`grab_php_config_value $CI_ENV_MONGO_CONF_FILE mongo_hostbase`
	MONGO_USER=`grab_php_config_value $CI_ENV_MONGO_CONF_FILE mongo_username`
	MONGO_PASS=`grab_php_config_value $CI_ENV_MONGO_CONF_FILE mongo_password`
	MONGO_DB=`grab_php_config_value $CI_ENV_MONGO_CONF_FILE mongo_database`

	WHICH_MONGO_CONF="codeigniter environment ($CI_ENV_MONGO_CONF_FILE)"

# Check for configuration file as fallback.
elif [ -e "$MONGO_CONF_FILE" ]; then
	source "$MONGO_CONF_FILE"
	WHICH_CONF="lax mongo conf file ($MONGO_CONF_FILE)"
fi

# we have all the mongo creds
if [[ "${MONGO_HOST}" && "${MONGO_USER}" && "${MONGO_PASS}" && "${MONGO_DB}" ]]; then
	MONGO="true";
fi;

# Now that we have complete config data, set locations of dump files.
FROM_DATA_FILE="$DIR/.sql/$ENV-data.sql"
FROM_SCHEMA_FILE="$DIR/.sql/$ENV-schema.sql"
FROM_ROUTINES_FILE="$DIR/.sql/$ENV-routines.sql"

TO_DATA_FILE="$DIR/.sql/$ENV_TO-data.sql"
TO_SCHEMA_FILE="$DIR/.sql/$ENV_TO-schema.sql"
TO_ROUTINES_FILE="$DIR/.sql/$ENV_TO-routines.sql"

FROM_MONGO_DIR="$DIR/.mongo/$ENV"
TO_MONGO_DIR="$DIR/.mongo/$ENV_TO"

###########################################################
## Main logic.                                           ##
###########################################################

case $1 in
	"load")
		check_mysql_db_connection
		if [ "${MONGO}" ]; then
			check_mongo_db_connection
		fi
		load
		;;
	"dump")
		check_mysql_db_connection
		if [ "${MONGO}" ]; then
			check_mongo_db_connection
		fi
		dump
		;;
	"wipe")
		if [ "$ENV_TO" = "" ]; then
			usage
		else
			wipe
		fi
		;;
	"debug")
		cat <<HEREDOC
# Possible configuration paths:
	EEMASTERCONF_FILE:	$EEMASTERCONF_FILE
	CI_ENV_CONF_FILE:	$CI_ENV_CONF_FILE
	CONF_FILE:			$CONF_FILE
# Using configuration from $WHICH_CONF:
	DB:		$DB
	HOST:	$HOST
	PORT:	$PORT
	USER:	$USER
	PASS:	$PASS
# Data to be read from ($ENV):
	FROM_DATA_FILE:		$FROM_DATA_FILE
	FROM_SCHEMA_FILE:	$FROM_SCHEMA_FILE
	FROM_ROUTINES_FILE:	$FROM_ROUTINES_FILE
# Data to be saved to ($ENV_TO):
	TO_DATA_FILE:		$TO_DATA_FILE
	TO_SCHEMA_FILE:		$TO_SCHEMA_FILE
	TO_ROUTINES_FILE:	$TO_ROUTINES_FILE
HEREDOC
		if [ "${MONGO}" ]; then
			echo "MONGO DB:	$MONGO_DB"
			echo "MONGO HOST:	$MONGO_HOST"
			echo "MONGO USER:	$MONGO_USER"
			echo "MONGO PASS:	$MONGO_PASS"
		fi
		;;
	*)
		usage
		;;
esac

# Exit with success code if we got to this point.
exit 0
